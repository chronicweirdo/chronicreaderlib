<!DOCTYPE html>
<html>
<head>
    <script src="/libs/jszip.js"></script>
    <!-- https://github.com/43081j/rar.js -->
    <!--script src="/libs/rar.js"></script-->
    <script src="/libs/libunrar.js"></script>
    <script src="/libs/reader.js"></script>
    <script>
        function tos(b, l = null) {
            let s = b.toString(2)
            if (l == null) {
                if (0 < s.length && s.length < 4) {
                    s = s.padStart(4, '0')
                } else if (4 < s.length && s.length < 8) {
                    s = s.padStart(8, '0')
                } else if (8 < s.length && s.length < 16) {
                    s = s.padStart(16, '0')
                } else if (16 < s.length && s.length < 32) {
                    s = s.padStart(32, '0')
                }
            } else {
                s = s.padStart(l, '0')
            }
            return s
        }
        class RarEntry {
            constructor(name, unpVer, headerStart, dataStart, dataSize) {
                this.name = name
                this.unpVer = unpVer
                this.headerStart = headerStart
                this.dataStart = dataStart
                this.dataSize = dataSize
            }
        }
        class RarReader {
            RAR_FILE_SIGNATURE = '\x52\x61\x72\x21\x1a\x07\x00'
            
            // https://www.rarlab.com/technote.htm
            // https://codedread.github.io/bitjs/docs/unrar.html
            // http://acritum.com/winrar/rar-format
            constructor(bytes /*as ArrayBuffer*/) {
                this.bytes = bytes
                this.entries = []
                this.verifySignature()
                let mainHeaderEnd = this.readHeader(7)
                let end = mainHeaderEnd
                while (end && end < this.bytes.byteLength) {
                    let newEnd = this.readHeader(end)
                    end = newEnd
                }
                console.log(this.entries)
                this.getEntry(0)
            }

            verifySignature() {
                var signatureBytes = this.bytes.slice(0, 7)
                const signatureView = new DataView(signatureBytes)
                if (getString(signatureView, 7, 0, true) !== this.RAR_FILE_SIGNATURE) {
                    console.log('Invalid RAR archive');
                    throw "not a RAR file"
                } else {
                    console.log('valid rar archive')
                }
            }

            BASE_HEADER_LENGTH = 2 + 1 + 2 + 2
            HEADER_TYPE_MAIN_HEADER = 0x73
            HEADER_TYPE_FILE_HEADER = 0x74
            HEADER_FLAG_MHD_ENCRYPTVER = 0x0200
            HEADER_FLAG_LHD_LARGE = 0x0100
            HEADER_FLAG_LHD_SALT = 0x0400
            HEADER_FLAG_LHD_EXTTIME = 0x1000
            HEADER_FLAG_LARGE_HEADER_SIZE = 0x8000
            readHeader(start) {
                let headerBytes = this.bytes.slice(start, start + this.BASE_HEADER_LENGTH)
                let headerView = new DataView(headerBytes)

                let crc = getString(headerView, 2, 0, true)
                let type = headerView.getUint8(2)
                let flags = headerView.getUint16(3)
                let isEncrypted = (this.HEADER_FLAG_MHD_ENCRYPTVER & flags) != 0
                let lhdLargeIsSet = (this.HEADER_FLAG_LHD_LARGE & flags) != 0
                let lhdSaltIsSet = (this.HEADER_FLAG_LHD_SALT & flags) != 0
                let lhdExtTimeIsSet = (this.HEADER_FLAG_LHD_EXTTIME & flags) != 0
                let headerSize = headerView.getUint16(5, true)
                let restStart = start + this.BASE_HEADER_LENGTH
                
                if (type == this.HEADER_TYPE_MAIN_HEADER) {
                    let headerEnd = restStart + 2 + 4 + (isEncrypted ? 1 : 0)
                    let restOfHeaderView = new DataView(this.bytes.slice(restStart, headerEnd))
                    return headerEnd
                } else if (type == this.HEADER_TYPE_FILE_HEADER) {
                    let end = restStart + 4 + 4 + 1 + 4 + 4 + 1 + 1 + 2 + 4 // general structure end
                    let fileHeaderView = new DataView(this.bytes.slice(restStart, end))

                    let packSize = fileHeaderView.getUint32(0, true)
                    let packedDataSize = packSize
                    let unpSize = fileHeaderView.getUint32(4, true)
                    let hostOs = fileHeaderView.getUint8(8)
                    let fileCrc = fileHeaderView.getUint32(9)
                    let fileTime = fileHeaderView.getUint32(13)
                    let unpVer = fileHeaderView.getUint8(17)
                    let method = fileHeaderView.getUint8(18)
                    let nameSize = fileHeaderView.getInt16(19, true) // todo: should all be read with little endian?
                    let fileAttr = fileHeaderView.getUint32(21)

                    if (lhdLargeIsSet) {
                        let largeStart = end
                        end += 8
                        let highSizeView = new DataView(this.bytes.slice(largeStart, end))
                        let highPackSize = highSizeView.getUint32(0, true)
                        packedDataSize += highPackSize * 0x100000000
                        let highUnpSize = highSizeView.getUint32(4, true)
                    }

                    let fileNameStart = end
                    end += nameSize
                    let nameView = new DataView(this.bytes.slice(fileNameStart, end))
                    let name = getString(nameView, nameSize, 0, true)

                    if (lhdSaltIsSet) {
                        let saltStart = end
                        end += 8
                    }

                    if (lhdExtTimeIsSet) {
                        throw "ext time section not supported"
                    }
                    let entry = new RarEntry(name, unpVer, start, start + headerSize, packedDataSize)
                    this.entries.push(entry)
                    return start + headerSize + packedDataSize
                }
            }
            // https://www.rfc-editor.org/rfc/rfc1951#page-6
            getEntry(index) {
                console.log("processing entry")
                let entry = this.entries[index]

                let entryBytes = this.bytes.slice(entry.dataStart, entry.dataStart + entry.dataSize)
                let data = new DataView(entryBytes)
                let b = data.getUint8(0)
                console.log(tos(b))

                let isPpm = b & 0b1000000 != 0
                console.log("is ppm: " + isPpm)
                let keepOldTable = b & 0b0100000 != 0
                console.log("keep old table: " + keepOldTable)

                for (let i = 0; i < 20; i++) {
                    let b = data.getUint8(i + 1)
                    console.log(tos(b, 8))
                }
            }

            
        }

        var rar = null

        var url = "/books/RangerHouse.cbr";
        function getString(view, length, offset, raw) {
            offset = offset || 0;
            length = length || (view.byteLength - offset);
            if (length < 0) {
                length += view.byteLength;
            }
            let str = '';
            if (typeof Buffer !== 'undefined') {
                const data = [];
                for (let i = offset; i < (offset + length); i++) {
                    data.push(view.getUint8(i));
                }
                return (new Buffer(data)).toString();
            }
            else {
                for (let i = offset; i < (offset + length); i++) {
                    str += String.fromCharCode(view.getUint8(i));
                }
                if (raw) {
                    return str;
                }
                // TODO: why does this work?
                return decodeURIComponent(window.escape(str));
            }
        }

        // https://stackoverflow.com/questions/10982712/convert-binary-data-to-base64-with-javascript
        var encoder = new TextEncoder("ascii");
        var decoder = new TextDecoder("ascii");
        var base64Table = encoder.encode('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=');
        function toBase64(dataArr){
            var padding = dataArr.byteLength % 3;
            var len = dataArr.byteLength - padding;
            padding = padding > 0 ? (3 - padding) : 0;
            var outputLen = ((len/3) * 4) + (padding > 0 ? 4 : 0);
            var output = new Uint8Array(outputLen);
            var outputCtr = 0;
            for(var i=0; i<len; i+=3){              
                var buffer = ((dataArr[i] & 0xFF) << 16) | ((dataArr[i+1] & 0xFF) << 8) | (dataArr[i+2] & 0xFF);
                output[outputCtr++] = base64Table[buffer >> 18];
                output[outputCtr++] = base64Table[(buffer >> 12) & 0x3F];
                output[outputCtr++] = base64Table[(buffer >> 6) & 0x3F];
                output[outputCtr++] = base64Table[buffer & 0x3F];
            }
            if (padding == 1) {
                var buffer = ((dataArr[len] & 0xFF) << 8) | (dataArr[len+1] & 0xFF);
                output[outputCtr++] = base64Table[buffer >> 10];
                output[outputCtr++] = base64Table[(buffer >> 4) & 0x3F];
                output[outputCtr++] = base64Table[(buffer << 2) & 0x3F];
                output[outputCtr++] = base64Table[64];
            } else if (padding == 2) {
                var buffer = dataArr[len] & 0xFF;
                output[outputCtr++] = base64Table[buffer >> 2];
                output[outputCtr++] = base64Table[(buffer << 4) & 0x3F];
                output[outputCtr++] = base64Table[64];
                output[outputCtr++] = base64Table[64];
            }
            
            var ret = decoder.decode(output);
            output = null;
            dataArr = null;
            return ret;
        }

        window.onload = function() {
            fetch(url)
                .then(res => res.blob())
                .then(blob => {
                    console.log(blob)
                    return blob.arrayBuffer()
                })
                .then(ab => {
                    console.log(ab)
                    // https://github.com/wcchoi/libunrar-js
                    rar = readRARContent([{
                        "name": "rarfile.rar",
                        "content": new Uint8Array(ab)
                    }], null, null)
                    console.log(rar)
                    let files = Object.keys(rar.ls)
                    console.log(files)
                    let file = rar.ls[files[0]]
                    let fileContent = file.fileContent
                    console.log(fileContent)
                    var decoder = new TextDecoder('utf8')
                    //var b64encoded = btoa(decoder.decode(fileContent))
                    var b64encoded = toBase64(fileContent)
                    //console.log(b64encoded)
                    var imgData = "data:image/jpeg;base64," + b64encoded
                    console.log(imgData)
                    document.getElementById("page").src = imgData
                    //let rarReader = new RarReader(ab)

                    /*var header = ab.slice(0, 14)
                    const headerView = new DataView(header);
                    if (getString(headerView, 7, 0, true) !== '\x52\x61\x72\x21\x1a\x07\x00') {
                        console.log('Invalid RAR archive');
                    } else {
                        console.log('valid rar archive')
                    }
                    const headerType = headerView.getUint8(9);
                    console.log("header type: " + headerType.toString(2))
                    const headerFlags = headerView.getUint16(10, true);
                    console.log("header flags: " + headerFlags.toString(2))
                    const headerSize = headerView.getUint16(12, true);
                    console.log("header size: " + headerSize.toString(2))*/
                })
        }
    </script>
</head>
<body>
    Rar test
    <img id="page" />
</body>
</html>