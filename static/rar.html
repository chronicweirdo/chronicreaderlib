<!DOCTYPE html>
<html>
<head>
    <script src="/libs/jszip.js"></script>
    <!-- https://github.com/43081j/rar.js -->
    <script src="/libs/rar.js"></script>
    <script src="/libs/reader.js"></script>
    <script>
        class RarEntry {
            constructor(name, unpVer, headerStart, dataStart, dataSize) {
                this.name = name
                this.unpVer = unpVer
                this.headerStart = headerStart
                this.dataStart = dataStart
                this.dataSize = dataSize
            }
        }
        class RarReader {
            RAR_FILE_SIGNATURE = '\x52\x61\x72\x21\x1a\x07\x00'
            
            // https://www.rarlab.com/technote.htm
            // https://codedread.github.io/bitjs/docs/unrar.html
            // http://acritum.com/winrar/rar-format
            constructor(bytes /*as ArrayBuffer*/) {
                this.bytes = bytes
                this.entries = []
                this.verifySignature()
                let mainHeaderEnd = this.readHeader(7)
                let end = mainHeaderEnd
                while (end && end < this.bytes.byteLength) {
                    let newEnd = this.readHeader(end)
                    end = newEnd
                }
                console.log(this.entries)
            }

            verifySignature() {
                var signatureBytes = this.bytes.slice(0, 7)
                const signatureView = new DataView(signatureBytes)
                if (getString(signatureView, 7, 0, true) !== this.RAR_FILE_SIGNATURE) {
                    console.log('Invalid RAR archive');
                    throw "not a RAR file"
                } else {
                    console.log('valid rar archive')
                }
            }

            BASE_HEADER_LENGTH = 2 + 1 + 2 + 2
            HEADER_TYPE_MAIN_HEADER = 0x73
            HEADER_TYPE_FILE_HEADER = 0x74
            HEADER_FLAG_MHD_ENCRYPTVER = 0x0200
            HEADER_FLAG_LHD_LARGE = 0x0100
            HEADER_FLAG_LHD_SALT = 0x0400
            HEADER_FLAG_LHD_EXTTIME = 0x1000
            HEADER_FLAG_LARGE_HEADER_SIZE = 0x8000
            readHeader(start) {
                let headerBytes = this.bytes.slice(start, start + this.BASE_HEADER_LENGTH)
                let headerView = new DataView(headerBytes)

                let crc = getString(headerView, 2, 0, true)
                let type = headerView.getUint8(2)
                let flags = headerView.getUint16(3)
                let isEncrypted = (this.HEADER_FLAG_MHD_ENCRYPTVER & flags) != 0
                let lhdLargeIsSet = (this.HEADER_FLAG_LHD_LARGE & flags) != 0
                let lhdSaltIsSet = (this.HEADER_FLAG_LHD_SALT & flags) != 0
                let lhdExtTimeIsSet = (this.HEADER_FLAG_LHD_EXTTIME & flags) != 0
                let headerSize = headerView.getUint16(5, true)
                let restStart = start + this.BASE_HEADER_LENGTH
                
                if (type == this.HEADER_TYPE_MAIN_HEADER) {
                    let headerEnd = restStart + 2 + 4 + (isEncrypted ? 1 : 0)
                    let restOfHeaderView = new DataView(this.bytes.slice(restStart, headerEnd))
                    return headerEnd
                } else if (type == this.HEADER_TYPE_FILE_HEADER) {
                    let end = restStart + 4 + 4 + 1 + 4 + 4 + 1 + 1 + 2 + 4 // general structure end
                    let fileHeaderView = new DataView(this.bytes.slice(restStart, end))

                    let packSize = fileHeaderView.getUint32(0, true)
                    let packedDataSize = packSize
                    let unpSize = fileHeaderView.getUint32(4, true)
                    let hostOs = fileHeaderView.getUint8(8)
                    let fileCrc = fileHeaderView.getUint32(9)
                    let fileTime = fileHeaderView.getUint32(13)
                    let unpVer = fileHeaderView.getUint8(17)
                    let method = fileHeaderView.getUint8(18)
                    let nameSize = fileHeaderView.getInt16(19, true) // todo: should all be read with little endian?
                    let fileAttr = fileHeaderView.getUint32(21)

                    if (lhdLargeIsSet) {
                        let largeStart = end
                        end += 8
                        let highSizeView = new DataView(this.bytes.slice(largeStart, end))
                        let highPackSize = highSizeView.getUint32(0, true)
                        packedDataSize += highPackSize * 0x100000000
                        let highUnpSize = highSizeView.getUint32(4, true)
                    }

                    let fileNameStart = end
                    end += nameSize
                    let nameView = new DataView(this.bytes.slice(fileNameStart, end))
                    let name = getString(nameView, nameSize, 0, true)

                    if (lhdSaltIsSet) {
                        let saltStart = end
                        end += 8
                    }

                    if (lhdExtTimeIsSet) {
                        throw "ext time section not supported"
                    }
                    let entry = new RarEntry(name, unpVer, start, start + headerSize, packedDataSize)
                    this.entries.push(entry)
                    return start + headerSize + packedDataSize
                }
            }
            getEntry(index) {
                let entry = this.entries[index]

                let entryBytes = this.bytes.slice(entry.dataStart, entry.dataStart + entry.dataBytes)

            }
        }

        var url = "/books/RangerHouse.cbr";
        function getString(view, length, offset, raw) {
            offset = offset || 0;
            length = length || (view.byteLength - offset);
            if (length < 0) {
                length += view.byteLength;
            }
            let str = '';
            if (typeof Buffer !== 'undefined') {
                const data = [];
                for (let i = offset; i < (offset + length); i++) {
                    data.push(view.getUint8(i));
                }
                return (new Buffer(data)).toString();
            }
            else {
                for (let i = offset; i < (offset + length); i++) {
                    str += String.fromCharCode(view.getUint8(i));
                }
                if (raw) {
                    return str;
                }
                // TODO: why does this work?
                return decodeURIComponent(window.escape(str));
            }
        }
        window.onload = function() {
            fetch(url)
                .then(res => res.blob())
                .then(blob => {
                    console.log(blob)
                    return blob.arrayBuffer()
                })
                .then(ab => {
                    console.log(ab)
                    let rarReader = new RarReader(ab)

                    /*var header = ab.slice(0, 14)
                    const headerView = new DataView(header);
                    if (getString(headerView, 7, 0, true) !== '\x52\x61\x72\x21\x1a\x07\x00') {
                        console.log('Invalid RAR archive');
                    } else {
                        console.log('valid rar archive')
                    }
                    const headerType = headerView.getUint8(9);
                    console.log("header type: " + headerType.toString(2))
                    const headerFlags = headerView.getUint16(10, true);
                    console.log("header flags: " + headerFlags.toString(2))
                    const headerSize = headerView.getUint16(12, true);
                    console.log("header size: " + headerSize.toString(2))*/
                })
        }
    </script>
</head>
<body>
    Rar test
</body>
</html>