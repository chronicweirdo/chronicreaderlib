<!DOCTYPE html>
<html>
<head>
    <script src="/libs/jszip.js"></script>
    <!-- https://github.com/43081j/rar.js -->
    <script src="/libs/rar.js"></script>
    <script src="/libs/reader.js"></script>
    <script>
        class RarReader {
            RAR_FILE_SIGNATURE = '\x52\x61\x72\x21\x1a\x07\x00'
            
            // https://www.rarlab.com/technote.htm
            // https://codedread.github.io/bitjs/docs/unrar.html
            // http://acritum.com/winrar/rar-format
            constructor(bytes /*as ArrayBuffer*/) {
                this.bytes = bytes
                this.names = []
                this.verifySignature()
                let mainHeaderEnd = this.readHeader(7)
                console.log("main header end: " + mainHeaderEnd)
                let end = mainHeaderEnd
                console.log("archive size: " + this.bytes.byteLength)
                while (end && end < this.bytes.byteLength) {
                    let newEnd = this.readHeader(end)
                    console.log("read until " + newEnd)
                    end = newEnd
                }
                console.log(this.names.length)
                this.names.sort()
                console.log(this.names)
                //console.log("first file header end: " + firstFileHeaderEnd)
                //let secondFileHeaderEnd = this.readHeader(firstFileHeaderEnd)
            }

            verifySignature() {
                var signatureBytes = this.bytes.slice(0, 7)
                const signatureView = new DataView(signatureBytes)
                if (getString(signatureView, 7, 0, true) !== this.RAR_FILE_SIGNATURE) {
                    console.log('Invalid RAR archive');
                    throw "not a RAR file"
                } else {
                    console.log('valid rar archive')
                }
            }

            BASE_HEADER_LENGTH = 2 + 1 + 2 + 2
            HEADER_TYPE_MAIN_HEADER = 0x73
            HEADER_TYPE_FILE_HEADER = 0x74
            HEADER_FLAG_MHD_ENCRYPTVER = 0x0200
            HEADER_FLAG_LHD_LARGE = 0x0100
            HEADER_FLAG_LHD_SALT = 0x0400
            HEADER_FLAG_LHD_EXTTIME = 0x1000
            HEADER_FLAG_LARGE_HEADER_SIZE = 0x8000
            readHeader(start) {
                let headerBytes = this.bytes.slice(start, start + this.BASE_HEADER_LENGTH)
                let headerView = new DataView(headerBytes)

                let crc = getString(headerView, 2, 0, true)
                let type = headerView.getUint8(2)
                //console.log(type.toString(16))
                //console.log(type == 0x73)
                let flags = headerView.getUint16(3) // getString(headerView, 2, 3, true)
                //console.log(flags.toString(16))
                //console.log(this.HEADER_FLAG_MHD_ENCRYPTVER & flags)
                let isEncrypted = (this.HEADER_FLAG_MHD_ENCRYPTVER & flags) != 0
                let lhdLargeIsSet = (this.HEADER_FLAG_LHD_LARGE & flags) != 0
                let lhdSaltIsSet = (this.HEADER_FLAG_LHD_SALT & flags) != 0
                let lhdExtTimeIsSet = (this.HEADER_FLAG_LHD_EXTTIME & flags) != 0
                //let largeHeaderSizeIsSet = (this.HEADER_FLAG_LARGE_HEADER_SIZE & flags) != 0
                //console.log(isEncrypted)
                let headerSize = headerView.getUint16(5, true) //getString(headerView, 2, 5, true)

                let restStart = start + this.BASE_HEADER_LENGTH
                /*if (largeHeaderSizeIsSet) {
                    console.log("large header detected!")
                    let restOfHeaderSize = new DataView(this.bytes.slice(restStart, restStart + 4)).getUint32(0, true)
                    restStart = restStart + 4
                    headerSize = headerSize + restOfHeaderSize // todo: is this correct, just an addition?
                }*/
                //console.log("header size: " + headerSize)
                //console.log("header size: " + headerSize.toString(2))

                /*let headerCrcBytes = this.bytes.slice(start, start+2)
                let headerTypeBytes = this.bytes.slice(start + 2, start+2+1)
                console.log(headerTypeBytes)
                let headerFlagsBytes = this.bytes.slice(start + 2 + 1, start+2+1+2)
                let headerSizeBytes = this.bytes.slice(start + 2 + 1 + 2, start+2+1+2+2)*/

                
                if (type == this.HEADER_TYPE_MAIN_HEADER) {
                    let headerEnd = restStart + 2 + 4 + (isEncrypted ? 1 : 0)
                    let restOfHeaderView = new DataView(this.bytes.slice(restStart, headerEnd))
                    return headerEnd
                } else if (type == this.HEADER_TYPE_FILE_HEADER) {
                    let end = restStart + 4 + 4 + 1 + 4 + 4 + 1 + 1 + 2 + 4 // general structure end
                    let fileHeaderView = new DataView(this.bytes.slice(restStart, end))

                    let packSize = fileHeaderView.getUint32(0, true)
                    let packedDataSize = packSize
                    let unpSize = fileHeaderView.getUint32(4, true)
                    //console.log("unpacked size: " + unpSize)
                    //console.log("unpacked size: " + unpSize.toString(2))
                    let hostOs = fileHeaderView.getUint8(8)
                    let fileCrc = fileHeaderView.getUint32(9)
                    let fileTime = fileHeaderView.getUint32(13)
                    let unpVer = fileHeaderView.getUint8(17)
                    let method = fileHeaderView.getUint8(18)
                    let nameSize = fileHeaderView.getInt16(19, true) // todo: should all be read with little endian?
                    //console.log("name size: " + nameSize)
                    //console.log(nameSize.toString(2))
                    let fileAttr = fileHeaderView.getUint32(21)

                    if (lhdLargeIsSet) {
                        //console.log("large file!")
                        let largeStart = end
                        end += 8
                        let highSizeView = new DataView(this.bytes.slice(largeStart, end))
                        let highPackSize = highSizeView.getUint32(0, true)
                        packedDataSize += highPackSize * 0x100000000
                        let highUnpSize = highSizeView.getUint32(4, true)
                    }
                    //console.log("packed data size: " + packedDataSize)
                    //console.log("packed data size: " + packedDataSize.toString(2))

                    let fileNameStart = end
                    end += nameSize
                    let nameView = new DataView(this.bytes.slice(fileNameStart, end))
                    let name = getString(nameView, nameSize, 0, true)
                    console.log("name: " + name)
                    this.names.push(name)

                    if (lhdSaltIsSet) {
                        //console.log("reading salt")
                        let saltStart = end
                        end += 8
                    }

                    if (lhdExtTimeIsSet) {
                        throw "ext time section not supported"
                    }
                    //console.log("read header size: " + (end - start))
                    return start + headerSize + packedDataSize
                }
            }
        }

        var url = "/books/RangerHouse.cbr";
        function getString(view, length, offset, raw) {
            offset = offset || 0;
            length = length || (view.byteLength - offset);
            if (length < 0) {
                length += view.byteLength;
            }
            let str = '';
            if (typeof Buffer !== 'undefined') {
                const data = [];
                for (let i = offset; i < (offset + length); i++) {
                    data.push(view.getUint8(i));
                }
                return (new Buffer(data)).toString();
            }
            else {
                for (let i = offset; i < (offset + length); i++) {
                    str += String.fromCharCode(view.getUint8(i));
                }
                if (raw) {
                    return str;
                }
                // TODO: why does this work?
                return decodeURIComponent(window.escape(str));
            }
        }
        window.onload = function() {
            fetch(url)
                .then(res => res.blob())
                .then(blob => {
                    console.log(blob)
                    return blob.arrayBuffer()
                })
                .then(ab => {
                    console.log(ab)
                    let rarReader = new RarReader(ab)

                    /*var header = ab.slice(0, 14)
                    const headerView = new DataView(header);
                    if (getString(headerView, 7, 0, true) !== '\x52\x61\x72\x21\x1a\x07\x00') {
                        console.log('Invalid RAR archive');
                    } else {
                        console.log('valid rar archive')
                    }
                    const headerType = headerView.getUint8(9);
                    console.log("header type: " + headerType.toString(2))
                    const headerFlags = headerView.getUint16(10, true);
                    console.log("header flags: " + headerFlags.toString(2))
                    const headerSize = headerView.getUint16(12, true);
                    console.log("header size: " + headerSize.toString(2))*/
                })
        }
    </script>
</head>
<body>
    Rar test
</body>
</html>